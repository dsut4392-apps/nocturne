// src/Web/packages/remote-function-codegen/src/generators/remote-functions.ts
import type { OperationInfo, ParsedSpec } from '../types.js';
import {
  operationIdToFunctionName,
  tagToFileName,
  resolveInvalidation,
} from '../utils/naming.js';

export function generateRemoteFunctions(parsed: ParsedSpec): Map<string, string> {
  const fileContents = new Map<string, string>();

  // Group operations by tag
  const byTag = new Map<string, OperationInfo[]>();
  for (const op of parsed.operations) {
    const existing = byTag.get(op.tag) ?? [];
    existing.push(op);
    byTag.set(op.tag, existing);
  }

  // Generate file for each tag
  for (const [tag, operations] of byTag) {
    const fileName = `${tagToFileName(tag)}.remote.generated.ts`;
    const content = generateTagFile(tag, operations, parsed);
    fileContents.set(fileName, content);
  }

  // Generate barrel export
  const indexContent = generateIndexFile(Array.from(byTag.keys()));
  fileContents.set('index.ts', indexContent);

  return fileContents;
}

function generateTagFile(tag: string, operations: OperationInfo[], parsed: ParsedSpec): string {
  const schemaImports = new Set<string>();
  const typeImports = new Set<string>();

  // Collect schema imports for request bodies and type imports for casting
  for (const op of operations) {
    if (op.requestBodySchema) {
      schemaImports.add(op.requestBodySchema);
      // Also import the type for casting (schema name without 'Schema' suffix)
      const typeName = op.requestBodySchema.replace(/Schema$/, '');
      typeImports.add(typeName);
    }
  }

  const schemaImportLine = schemaImports.size > 0
    ? `import { ${Array.from(schemaImports).join(', ')} } from '$lib/api/generated/schemas';\n`
    : '';

  const typeImportLine = typeImports.size > 0
    ? `import type { ${Array.from(typeImports).join(', ')} } from '$api';\n`
    : '';

  const functions = operations.map(op => generateFunction(op, tag, operations)).join('\n\n');

  return `// AUTO-GENERATED - DO NOT EDIT
// Generated by @nocturne/remote-function-codegen
// Source: openapi.json

import { getRequestEvent, query, command } from '$app/server';
import { error } from '@sveltejs/kit';
import { z } from 'zod';
${schemaImportLine}${typeImportLine}
${functions}
`;
}

function generateFunction(op: OperationInfo, tag: string, allOpsInTag: OperationInfo[]): string {
  const functionName = operationIdToFunctionName(op.operationId);
  const clientProperty = getClientProperty(tag);
  const methodName = getMethodName(op.operationId, tag);

  if (op.remoteType === 'query') {
    return generateQueryFunction(op, functionName, clientProperty, methodName);
  } else {
    return generateCommandFunction(op, functionName, clientProperty, methodName, tag, allOpsInTag);
  }
}

function generateQueryFunction(
  op: OperationInfo,
  functionName: string,
  clientProperty: string,
  methodName: string
): string {
  const { schemaArg, paramList, apiCallArgs } = buildParameterMapping(op);
  const comment = op.summary ? `/** ${op.summary} */\n` : '';

  return `${comment}export const ${functionName} = query(${schemaArg}, async (${paramList}) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    return await apiClient.${clientProperty}.${methodName}(${apiCallArgs});
  } catch (err) {
    console.error('Error in ${clientProperty}.${methodName}:', err);
    throw error(500, 'Failed to ${functionName.replace(/([A-Z])/g, ' $1').toLowerCase().trim()}');
  }
});`;
}

function generateCommandFunction(
  op: OperationInfo,
  functionName: string,
  clientProperty: string,
  methodName: string,
  tag: string,
  allOpsInTag: OperationInfo[]
): string {
  const { schemaArg, paramList, apiCallArgs, hasPathId } = buildParameterMapping(op);

  // Build invalidation calls
  const invalidations = op.invalidates.map(inv => {
    const resolved = resolveInvalidation(inv, tag);
    return resolved.functionName;
  });

  // Filter to only include functions that exist in the same file (same tag)
  const localFunctionNames = new Set(allOpsInTag.map(o => operationIdToFunctionName(o.operationId)));
  const localInvalidations = invalidations.filter(fn => localFunctionNames.has(fn));

  // Build refresh calls - use the actual id for single-item queries when available
  const refreshCallsArr = localInvalidations.map(fn => {
    // If this is a "get single item" query (like getDefinition) and we have an id, pass it
    const isSingleItemQuery = fn.match(/^get[A-Z][a-z]+$/) && !fn.endsWith('s');
    if (isSingleItemQuery && hasPathId) {
      return `${fn}(id).refresh()`;
    }
    return `${fn}(undefined).refresh()`;
  });

  const refreshCalls = refreshCallsArr.length > 0
    ? `
    await Promise.all([
      ${refreshCallsArr.join(',\n      ')}
    ]);`
    : '';

  const comment = op.summary ? `/** ${op.summary} */\n` : '';

  return `${comment}export const ${functionName} = command(${schemaArg}, async (${paramList}) => {
  const { locals } = getRequestEvent();
  const { apiClient } = locals;
  try {
    const result = await apiClient.${clientProperty}.${methodName}(${apiCallArgs});${refreshCalls}
    return result;
  } catch (err) {
    console.error('Error in ${clientProperty}.${methodName}:', err);
    throw error(500, 'Failed to ${functionName.replace(/([A-Z])/g, ' $1').toLowerCase().trim()}');
  }
});`;
}

function buildParameterMapping(op: OperationInfo): {
  schemaArg: string;
  paramList: string;
  apiCallArgs: string;
  hasPathId: boolean;
} {
  const pathParams = op.parameters.filter(p => p.in === 'path');
  const queryParams = op.parameters.filter(p => p.in === 'query');
  const hasPathId = pathParams.some(p => p.name === 'id');

  // Simple case: single path param (e.g., GET /notes/{id})
  if (pathParams.length === 1 && queryParams.length === 0 && !op.requestBodySchema) {
    const param = pathParams[0];
    return {
      schemaArg: 'z.string()',
      paramList: param.name,
      apiCallArgs: param.name,
      hasPathId,
    };
  }

  // Request body only
  if (pathParams.length === 0 && queryParams.length === 0 && op.requestBodySchema) {
    const typeName = op.requestBodySchema.replace(/Schema$/, '');
    return {
      schemaArg: op.requestBodySchema,
      paramList: 'request',
      apiCallArgs: `request as ${typeName}`,
      hasPathId,
    };
  }

  // Path param + request body (e.g., PUT /notes/{id})
  if (pathParams.length === 1 && op.requestBodySchema) {
    const param = pathParams[0];
    const typeName = op.requestBodySchema.replace(/Schema$/, '');
    return {
      schemaArg: `z.object({ ${param.name}: z.string() }).merge(${op.requestBodySchema})`,
      paramList: `{ ${param.name}, ...request }`,
      apiCallArgs: `${param.name}, request as ${typeName}`,
      hasPathId,
    };
  }

  // Query params only
  if (queryParams.length > 0 && !op.requestBodySchema) {
    const fields = queryParams.map(p => {
      const zodType = getZodType(p.type);
      return `${p.name}: ${zodType}${p.required ? '' : '.optional()'}`;
    });

    const schemaArg = `z.object({ ${fields.join(', ')} }).optional()`;
    const paramList = 'params';
    const apiCallArgs = queryParams.map(p => `params?.${p.name}`).join(', ');

    return { schemaArg, paramList, apiCallArgs, hasPathId };
  }

  // No params
  return {
    schemaArg: 'z.void().optional()',
    paramList: '_',
    apiCallArgs: '',
    hasPathId,
  };
}

function getZodType(type: string): string {
  switch (type) {
    case 'boolean': return 'z.boolean()';
    case 'number': return 'z.number()';
    case 'integer': return 'z.number().int()';
    case 'Date': return 'z.coerce.date()';
    default: return 'z.string()';
  }
}

/**
 * Get the apiClient property name for a tag.
 * This needs to match the existing api-client.ts property names.
 */
function getClientProperty(tag: string): string {
  // Handle common versioned tags
  const cleaned = tag.replace(/^V\d+\s*/i, '');

  // Map tag names to api-client property names
  const tagToProperty: Record<string, string> = {
    'Trackers': 'trackers',
    'Entries': 'entries',
    'Treatments': 'treatments',
    'Profile': 'profile',
    'Settings': 'settings',
    'Status': 'status',
    'StateSpans': 'stateSpans',
    'ChartData': 'chartData',
    'Notifications': 'v2Notifications',
    'Services': 'services',
    'Battery': 'battery',
    'Prediction': 'predictions',
    'Retrospective': 'retrospective',
    'UISettings': 'uiSettings',
    'ClockFaces': 'clockFaces',
    'Foods': 'foodsV4',
    'Food': 'food',
    'TreatmentFoods': 'treatmentFoods',
    'MealMatching': 'mealMatching',
    'Migration': 'migration',
    'Compatibility': 'compatibility',
    'Discrepancy': 'discrepancy',
    'Deduplication': 'deduplication',
    'Metadata': 'metadata',
    'Authentication': 'authentication',
    'Authorization': 'authorization',
  };

  return tagToProperty[cleaned] ?? cleaned.charAt(0).toLowerCase() + cleaned.slice(1);
}

/**
 * Get the method name from operationId.
 * NSwag generates method names by removing the tag prefix.
 * "Trackers_GetDefinitions" -> "getDefinitions"
 */
function getMethodName(operationId: string, tag: string): string {
  // Remove tag prefix if present
  const parts = operationId.split('_');
  const name = parts.length > 1 ? parts.slice(1).join('_') : parts[0];

  // Convert to camelCase
  return name.charAt(0).toLowerCase() + name.slice(1);
}

function generateIndexFile(tags: string[]): string {
  const exports = tags.map(tag => {
    const fileName = tagToFileName(tag);
    return `export * from './${fileName}.remote.generated';`;
  });

  return `// AUTO-GENERATED - DO NOT EDIT
// Generated by @nocturne/remote-function-codegen

${exports.join('\n')}
`;
}
